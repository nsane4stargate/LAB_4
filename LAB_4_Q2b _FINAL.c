#pragma config(Sensor, S1,     ,               sensorEV3_Touch)
#pragma config(Sensor, S4,     SONAR,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          LEFT,          tmotorEV3_Large, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorC,          RIGHT,         tmotorEV3_Large, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

program robot to maintain 30 cm distance to an obstacle.
if there is no obstacle within 60 cm, the robot should not move.
otherwise, the robot should advance or retreat until the distance
to the obstacle is 30 cm. use main task to control motors.

*/
int k = 3, desiredPower, maxPower =  20, minPower = -maxPower;
long currentPower;
float currentDistance = 0, error;

const float tolerance = 2, desiredDistance = 30, maxDistance = 60, nTurnRatio = 0; // 2 cm
int slewRate = 5 ;


// task to read range sensor
task readDistance()
{
	while(true)
	{
		currentDistance = getUSDistance(SONAR);
		displayCenteredBigTextLine(3, "dist: %.2f cm", currentDistance);
		sleep(10);
	}
}

task controllerTask()
{
	while(true){

		// Calculates error for later use when calculating desiredPower
		error = desiredDistance - currentDistance;

		// calculate desired power
		if (abs(error) > tolerance){
			desiredPower = k * error; // if we are outside the tolerance range, we want to move
			}else{
			currentPower = desiredPower = 0;
		}

		/* If robot is closer than 30 cm, it will reverse (-desiredPower) until it reaches
		* with the tolerance of 30 cm
		*/
		if(currentDistance < desiredDistance){
			if(currentPower + slewRate < -(desiredPower)){
				currentPower += slewRate;
				}else{
				if(currentPower - slewRate > -(desiredPower))
					currentPower -= slewRate;
			}
		}// end of if-else(currentDistance < desiredDistance)

		/* If robot is greater than the tolerance of 30 cm but less the 60cm, it will move forward
		* 	desiredPower until it reaches with the tolerance of 30 cm
		*/
		else if(currentDistance > desiredDistance && currentDistance < maxDistance){
			if(currentPower + slewRate < -(desiredPower)){
				currentPower += slewRate;
				}else{
				if(currentPower - slewRate > -(desiredPower))
					currentPower -= slewRate;
			}
		}// END of IF - ELSEIF STATEMENT
		else
			currentPower = 0;
		sleep(100);
	}// end of WHILE
}// End of Task


task main(){
	sensorReset(SONAR);
	displayCenteredBigTextLine(1, "Lab4Q2B");

	startTask(readDistance);
	startTask(controllerTask);
	while(true){
		displayCenteredBigTextLine(6, "%.2f", currentPower);
		setMotorSync(RIGHT, LEFT, nTurnRatio, currentPower); // move the motors
	}

}
